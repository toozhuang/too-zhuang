---
title: JavaScript 内存管理 （ 新手村）
date: 2020-07-20 12:25:21
tags: ["JavaScript"]
---

在学习闭包，等一系列的**现在我不懂**的知识中，发现， 内存回收是一个绕不过去的东西。 
在学习闭包，等一系列的**现在我不懂**的知识中，发现， 内存回收是一个绕不过去的东西。 
比如
> 在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去foo()的内容不会再被使用，所以很自然地会考虑对其进行回收。
在你不知道的 JavaScript 中就有这么一句话。 里面就有说到的**垃圾回收器**。

同样，在 MDN 的[内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)章节的简介部分，也有说过这么一句话，

> 像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 

确实， 对于我来讲， 就是这么个情况， 我会忽略释放/回收/分配这些步骤，想当然的用*自动回收*来安慰自己，不需要进一步的理解内存管理机制。 而事实证明， 忽略了这一部分， 会对后面的其他知识点的理解造成困扰。

不管什么程序语言，内存生命周期基本是一致的：
1 分配你所需要的内存
2 使用分配到的内存（读、写）
3 不需要时将其释放\归还

所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。

JavaScript 的内存分配是自动的， 他在定义变量/函数调用的时候就进行了内存的分配，当**内存不再需要**的时候释放。 

而**内存不再需要**这个部分是如何定义和甄别的，则需要垃圾回收的策略来帮助。 
去上面的链接读完以后（[内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)）， 不明不白， 主要是问中说的东西，太简洁了。
[知乎上有一篇文章](https://zhuanlan.zhihu.com/p/23992332)，看完以后，对于垃圾回收 和 闭包作用域的关系的理解更深刻了。

垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它 [原型](https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain) 的引用（隐式引用）和对它属性的引用（显式引用）。

上面的定义就引入了， **引用计数垃圾收集**的策略

### **引用计数垃圾收集**
垃圾回收基于的原理是，对于该变量/对象在未来程序中不会被访问，那么就可以释放该对象/变量所占用的内存。

```
let obj1 = { a: 1 }; // 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1 
let obj2 = obj1; // A 的引用个数变为 2

obj1 = 0; // A 的引用个数变为 1
obj2 = 0; // A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了
```

上面第一步， `{a：1}` 对象被赋予给了变量 obj1，姑且称之`{a:1}`为 A， 那么，计算机就给了 A分配了一个内存，且 obj1 是指向☝🏻这个内存的。 `{a:1}`就是这个内存地址上面的值。
也就是说， 我们的 A 就是一个被引用了一次， 被 obj1 引用。

第二步骤， `obj2 = obj1`， 那么 A 被引用了两次。
**这个时候 A 还在内存中， 因为有两个变量在引用这个对象**， 再进一步的话， 到了第三步和第四步， 我们的 obj1 and obj2 have been set to value 0, which means they lost the pointer(address) to `{a:1}`， 所以可以说 A 没有了任何的引用。

于是 A 就被回收了。 

##### 这就是我们说的计数垃圾收策略

这个策略有一个问题，如果两个 object 重复引用的话， 计数器（pointer 的 counter）就不会重置为0. 那就不会有内存的释放。

```
function func() {
    let obj1 = {};
    let obj2 = {};

    obj1.a = obj2; // obj1 引用 obj2
    obj2.a = obj1; // obj2 引用 obj1
}
```

上面的 `obj1` and `obj2` defined inside the function,  and 互相引用， 所以 虽然使用了 let， 但是依然不会被回收. 这里有一个疑问的是， obj1 和 obj2 在 func 的外面是访问不了的， undefined， 也就是说无法通过代码的形式来检测出来，只能自己体会，obj1 和 obj2 因为还有留存的引用， 所以不会被清零.

### 标记-清除（mark and sweep）策略
JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。

标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过可以想象，这种做法的效率没有标记-清除高。计算机中的很多做法都是互相妥协的结果，哪有什么十全十美的事儿呢。

## 结尾
到这里， 内存管理当然有很多的东西， 但到这里， 我已经有一个初步的理解了， 对于你不知道的 Javascript 上卷中 5.2上关于垃圾回收机制的一句带过背后的东西不再云里雾里。 目的也就达到了。



